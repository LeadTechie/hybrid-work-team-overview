---
phase: 01-foundation-data-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/services/csvService.ts
  - src/services/geocodingService.ts
  - src/services/validationService.ts
autonomous: true

must_haves:
  truths:
    - "CSV with comma delimiter parses correctly"
    - "CSV with semicolon delimiter parses correctly"
    - "Single address column is handled"
    - "Split address columns (street, postcode, city) are merged"
    - "Valid rows import, invalid rows are flagged with errors"
    - "German characters (umlauts) are preserved after parsing"
    - "Geocoding returns coordinates for valid German addresses"
    - "Geocoding progress callback is invoked"
    - "Failed geocodes are flagged, not blocking"
  artifacts:
    - path: "src/services/csvService.ts"
      provides: "CSV parsing with lenient validation"
      exports: ["parseOfficeCsv", "parseEmployeeCsv"]
    - path: "src/services/geocodingService.ts"
      provides: "Batch geocoding with progress"
      exports: ["batchGeocode"]
    - path: "src/services/validationService.ts"
      provides: "Zod schemas for validation"
      exports: ["OfficeSchema", "EmployeeSchema"]
  key_links:
    - from: "src/services/csvService.ts"
      to: "src/services/validationService.ts"
      via: "schema import"
      pattern: "import.*Schema.*from.*validationService"
    - from: "src/services/csvService.ts"
      to: "papaparse"
      via: "CSV parsing"
      pattern: "import Papa from 'papaparse'"
    - from: "src/services/geocodingService.ts"
      to: "Geoapify API"
      via: "fetch"
      pattern: "api.geoapify.com"
---

<objective>
Create CSV parsing and geocoding services that handle the core data pipeline logic.

Purpose: These services transform raw CSV input into validated, geocoded Office and Employee records. They implement the lenient validation (import valid, skip invalid) and auto-detection (delimiter, address format) per user decisions.
Output: Two services ready for UI integration - csvService.ts and geocodingService.ts
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-data-pipeline/01-CONTEXT.md
@.planning/phases/01-foundation-data-pipeline/01-RESEARCH.md
@.planning/phases/01-foundation-data-pipeline/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation schemas and CSV parsing service</name>
  <files>src/services/validationService.ts, src/services/csvService.ts</files>
  <action>
Create validationService.ts with Zod schemas:

```typescript
// Office schema - simple validation
export const OfficeSchema = z.object({
  name: z.string().min(1, 'Office name is required'),
  address: z.string().min(1, 'Address is required'),
});

// Employee schema - per CONTEXT.md requirements
export const EmployeeSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  address: z.string().min(1, 'Address is required'),
  team: z.string().min(1, 'Team is required'),
  department: z.string().optional().default(''),
  role: z.string().optional().default(''),
  assignedOffice: z.string().optional().default(''),
});
```

Create csvService.ts with:

1. **parseOfficeCsv(csvText: string): CsvParseResult<Office>**
   - Use PapaParse with header: true, skipEmptyLines: true
   - Auto-detect delimiter: delimitersToGuess: [',', ';', '\t']
   - Handle BOM: transformHeader removes \uFEFF and trims
   - Normalize headers to lowercase
   - Handle flexible address: single 'address' OR combine street+postcode+city
   - Validate each row with OfficeSchema
   - Collect valid rows, track invalid with row number and errors
   - Return { valid: Office[], invalid: ValidationError[], warnings: string[] }

2. **parseEmployeeCsv(csvText: string): CsvParseResult<Employee>**
   - Same PapaParse config as above
   - Handle flexible address columns: address OR street/strasse + postcode/plz + city/stadt/ort
   - Validate each row with EmployeeSchema
   - Generate UUID for each valid record
   - Set geocodeStatus: 'pending'
   - Return { valid: Employee[], invalid: ValidationError[], warnings: string[] }

3. **Type definitions:**
```typescript
interface ValidationError {
  row: number;        // 1-indexed, accounts for header
  data: Record<string, unknown>;
  errors: string[];
}

interface CsvParseResult<T> {
  valid: T[];
  invalid: ValidationError[];
  warnings: string[];  // PapaParse warnings
}
```

Key implementation details per CONTEXT.md decisions:
- Lenient validation: Don't reject entire import, collect errors per row
- Flexible address: Check for 'address' first, then try combining street+postcode+city
- German header variants: Accept 'strasse' for 'street', 'plz' for 'postcode', 'stadt'/'ort' for 'city'
  </action>
  <verify>
Create a simple test in App.tsx or browser console:

```typescript
import { parseEmployeeCsv } from './services/csvService';

// Test comma delimiter
const csv1 = `name,address,team
Anna Mueller,Hauptstr. 1, 60311 Frankfurt,Platform`;
console.log(parseEmployeeCsv(csv1));

// Test semicolon delimiter
const csv2 = `name;strasse;plz;stadt;team
Thomas Schmidt;Berliner Str. 5;10117;Berlin;Frontend`;
console.log(parseEmployeeCsv(csv2));

// Test invalid row handling
const csv3 = `name,address,team
Valid User,Some Address,TeamA
,Missing Name,TeamB`;
console.log(parseEmployeeCsv(csv3)); // Should have 1 valid, 1 invalid
```

All three tests should produce expected results without errors.
  </verify>
  <done>
CSV parsing handles both delimiters, both address formats, produces valid/invalid separation with error details. German characters preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create geocoding service with batch processing</name>
  <files>src/services/geocodingService.ts</files>
  <action>
Create geocodingService.ts with:

1. **batchGeocode function:**
```typescript
interface GeocodingProgress {
  completed: number;
  total: number;
  current: string;  // Current address being processed
}

interface GeocodingResult {
  address: string;
  coords: { lat: number; lon: number } | null;
  status: 'success' | 'failed';
  error?: string;
}

async function batchGeocode(
  addresses: string[],
  onProgress?: (progress: GeocodingProgress) => void
): Promise<GeocodingResult[]>
```

2. **Implementation details:**
   - Read API key from import.meta.env.VITE_GEOAPIFY_KEY
   - If no API key, return all addresses as failed with error "No API key configured"
   - Use Geoapify geocoding endpoint: https://api.geoapify.com/v1/geocode/search
   - Add filter=countrycode:de to restrict to Germany
   - Rate limit: max 5 requests per second (free tier)
   - Implement simple sequential processing with 200ms delay between requests
   - For each address:
     - Call onProgress with current status
     - Make fetch request
     - Parse response, extract coordinates from features[0].geometry.coordinates
     - Handle errors gracefully (network, 4xx, 5xx) - mark as failed, continue
   - Return array of results matching input order

3. **Error handling per CONTEXT.md:**
   - Flag and continue: If address can't be geocoded, mark with status 'failed', continue with others
   - No blocking: Failed geocodes don't stop the batch
   - Collect all results for summary display

4. **Helper function for single address (used internally):**
```typescript
async function geocodeAddress(address: string, apiKey: string): Promise<GeocodingResult>
```

Note: Not using @geoapify/request-rate-limiter in v1 - simple setTimeout-based rate limiting is sufficient for 50 addresses. Can upgrade later if needed.
  </action>
  <verify>
Test with a known German address (requires VITE_GEOAPIFY_KEY in .env):

```typescript
import { batchGeocode } from './services/geocodingService';

const addresses = [
  'Neue Mainzer Str. 52-58, 60311 Frankfurt am Main',
  'Invalid Address That Does Not Exist 12345',
  'Unter den Linden 21, 10117 Berlin'
];

batchGeocode(addresses, (progress) => {
  console.log(`${progress.completed}/${progress.total}: ${progress.current}`);
}).then(results => {
  console.log(results);
  // Expected: 2 success (Frankfurt, Berlin), 1 failed (invalid)
});
```

If no API key, all should return as failed with appropriate error message.
  </verify>
  <done>
Geocoding service returns coordinates for valid German addresses, handles failures gracefully, calls progress callback. Rate limiting prevents API throttling.
  </done>
</task>

</tasks>

<verification>
1. Import csvService in App.tsx and parse test CSV strings
2. Comma-delimited CSV parses correctly
3. Semicolon-delimited CSV parses correctly
4. Single 'address' column works
5. Split columns (street, postcode, city) combine correctly
6. Invalid rows appear in 'invalid' array with row numbers and errors
7. Valid rows appear in 'valid' array with UUIDs and 'pending' geocodeStatus
8. German characters (umlauts) preserved in parsed output
9. Geocoding returns coordinates for valid addresses (if API key present)
10. Geocoding progress callback fires for each address
11. Failed geocodes don't block batch processing
</verification>

<success_criteria>
- parseOfficeCsv and parseEmployeeCsv handle comma and semicolon delimiters
- Flexible address column detection works (single or split)
- Lenient validation: valid rows import, invalid rows flagged with errors
- German characters preserved (no encoding corruption)
- batchGeocode returns coordinates for valid German addresses
- Progress callback invoked during geocoding
- Failed geocodes flagged but don't block processing
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-pipeline/01-02-SUMMARY.md`
</output>
