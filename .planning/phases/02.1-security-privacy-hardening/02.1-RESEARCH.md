# Phase 2.1: Security & Privacy Hardening - Research

**Researched:** 2026-02-07
**Domain:** Browser security, localStorage encryption, local geocoding, CSP headers
**Confidence:** MEDIUM-HIGH

## Summary

This phase hardens the application for privacy-sensitive use with real employee data. The core strategy is "local by default": all data processing happens in the browser with no external API calls unless the user explicitly opts in.

The research identified four main implementation areas:
1. **Local geocoding** using bundled German postcode data (~8,000 entries with centroids)
2. **localStorage encryption** using either crypto-js with Zustand persist or native Web Crypto API
3. **CSP headers** configured via vite-plugin-content-security-policy or index.html meta tag
4. **Consent UX** following GDPR best practices with equal button prominence and clear privacy notices

**Primary recommendation:** Use the WZB plz_geocoord dataset (Apache 2.0) for bundled postcode centroids, crypto-js for localStorage encryption with Zustand persist, and CSP meta tag in index.html for simplicity.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| crypto-js | ^4.2 | AES encryption for localStorage | Most popular (16M+ weekly downloads), simple API, works with Zustand persist |
| zustand | 5.0.11 | State management (already installed) | Built-in persist middleware with custom storage support |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| vite-plugin-content-security-policy | latest | CSP headers in dev | Only if meta tag CSP insufficient |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| crypto-js | Web Crypto API (native) | Native = no dependency, but async-only makes Zustand integration complex |
| crypto-js | encrypt-storage | Higher-level API but adds another abstraction layer |
| Meta tag CSP | vite-plugin-csp | Plugin gives better dev/prod parity but more setup |

**Installation:**
```bash
npm install crypto-js
npm install -D @types/crypto-js
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── data/
│   └── germanPostcodes.ts          # Bundled ~8,000 PLZ centroids
├── services/
│   ├── localGeocodingService.ts    # Postcode-to-coords lookup (sync, no network)
│   ├── geocodingService.ts         # Accurate mode with Geoapify (user-initiated)
│   ├── encryptedStorage.ts         # Zustand-compatible encrypted storage
│   └── validationService.ts        # Updated schemas with postcode field
├── components/
│   ├── PrivacyBadge.tsx            # "All data stays in browser" indicator
│   ├── ClearDataButton.tsx         # Wipe all localStorage
│   └── AccurateGeocodingModal.tsx  # Consent modal for external API
└── stores/
    ├── employeeStore.ts            # Updated with encrypted persist
    └── officeStore.ts              # Updated with encrypted persist
```

### Pattern 1: Encrypted Zustand Storage
**What:** Custom storage adapter that encrypts before writing to localStorage
**When to use:** Any store containing user data (employees, offices)
**Example:**
```typescript
// Source: https://dev.to/cristhianleonli/encrypted-localstorage-with-zustand-4fdi
import { PersistStorage } from "zustand/middleware";
import CryptoJS from "crypto-js";

// Key derived from a constant - not truly secret but prevents casual inspection
const STORAGE_KEY = 'hwto-v1'; // Change on encryption format changes

export class EncryptedStorage implements PersistStorage<unknown> {
  getItem(key: string): string | null {
    const value = localStorage.getItem(key);
    if (!value) return null;
    try {
      const decrypted = CryptoJS.AES.decrypt(value, STORAGE_KEY);
      return decrypted.toString(CryptoJS.enc.Utf8) || null;
    } catch {
      return null; // Corrupted data - return null to reset state
    }
  }

  setItem(key: string, value: string): void {
    const encrypted = CryptoJS.AES.encrypt(value, STORAGE_KEY).toString();
    localStorage.setItem(key, encrypted);
  }

  removeItem(key: string): void {
    localStorage.removeItem(key);
  }
}

export const encryptedStorage = new EncryptedStorage();
```

### Pattern 2: Local Postcode Geocoding
**What:** Synchronous lookup of postcode centroid from bundled data
**When to use:** Default geocoding mode (no network requests)
**Example:**
```typescript
// src/services/localGeocodingService.ts
import { GERMAN_POSTCODES } from '../data/germanPostcodes';

export interface LocalGeocodeResult {
  postcode: string;
  coords: { lat: number; lon: number } | null;
  city: string | null;
  accuracy: 'postcode-centroid';
}

export function geocodeByPostcode(postcode: string): LocalGeocodeResult {
  const normalized = postcode.trim().replace(/\s/g, '');
  const data = GERMAN_POSTCODES[normalized];

  return {
    postcode: normalized,
    coords: data ? { lat: data.lat, lon: data.lon } : null,
    city: data?.place ?? null,
    accuracy: 'postcode-centroid',
  };
}
```

### Pattern 3: CSP Meta Tag
**What:** Content Security Policy via HTML meta tag
**When to use:** Simple apps where build-time injection not needed
**Example:**
```html
<!-- index.html -->
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  script-src 'self' 'unsafe-inline';
  style-src 'self' 'unsafe-inline';
  img-src 'self' https://*.tile.openstreetmap.org data:;
  connect-src 'self';
">
```

### Anti-Patterns to Avoid
- **API key in source code:** Never commit API keys; use runtime user-provided keys
- **Pre-checked consent boxes:** GDPR requires opt-in, not opt-out
- **Unequal button prominence:** Accept/Reject buttons must have visual parity
- **localStorage without encryption:** Even obfuscation prevents casual data viewing

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Encryption | Custom XOR/Base64 | crypto-js AES | Battle-tested, handles IV/padding correctly |
| German postcode data | Manual data entry | WZB plz_geocoord | Apache 2.0 licensed, ~8,000 entries, maintained |
| Consent modal | Basic alert() | Custom modal with links | GDPR requires T&C links, equal button sizing |
| Storage clearing | Manual key deletion | localStorage.clear() + store reset | Ensures complete removal |

**Key insight:** Browser encryption is obfuscation, not true security (key is in JS). Its purpose is preventing casual inspection, not protecting against determined attackers.

## Common Pitfalls

### Pitfall 1: Forgetting CSP Breaks External Resources
**What goes wrong:** CSP blocks legitimate resources (map tiles, external geocoding)
**Why it happens:** Default CSP is restrictive; connect-src blocks all fetch()
**How to avoid:** Explicitly whitelist OpenStreetMap tiles in img-src; update connect-src when enabling accurate mode
**Warning signs:** Map tiles fail to load, geocoding silently fails

### Pitfall 2: Zustand Persist Async Storage
**What goes wrong:** Using async Web Crypto API breaks Zustand persist
**Why it happens:** Zustand persist expects synchronous getItem/setItem
**How to avoid:** Use crypto-js (sync) or use createJSONStorage with async wrapper
**Warning signs:** State doesn't persist, hydration errors

### Pitfall 3: sessionStorage vs localStorage for API Key
**What goes wrong:** User must re-enter API key on page reload
**Why it happens:** sessionStorage clears on tab close (by design for security)
**How to avoid:** This is intentional - document the behavior, don't "fix" it
**Warning signs:** User complaints - explain in UI that this is a security feature

### Pitfall 4: CSP Breaks Vite HMR in Dev
**What goes wrong:** Hot module replacement fails with strict CSP
**Why it happens:** Vite injects inline scripts for HMR
**How to avoid:** Use less strict CSP in dev OR use vite-plugin-csp for nonce-based approach
**Warning signs:** Development server works but shows CSP violations in console

### Pitfall 5: Encryption Key Migration
**What goes wrong:** Changing encryption key invalidates all stored data
**Why it happens:** Old data encrypted with old key can't be decrypted
**How to avoid:** Include version in key name (e.g., 'hwto-v1'), handle decryption failures gracefully by returning null (forces state reset)
**Warning signs:** All user data disappears after update

## Code Examples

### Bundled Postcode Data Structure
```typescript
// src/data/germanPostcodes.ts
// Source: https://github.com/WZBSocialScienceCenter/plz_geocoord (Apache 2.0)
// ~8,000 entries, estimated ~200KB raw, ~50KB gzipped

export interface PostcodeEntry {
  lat: number;
  lon: number;
  place?: string; // City name if available
}

export const GERMAN_POSTCODES: Record<string, PostcodeEntry> = {
  "01067": { lat: 51.0575, lon: 13.7171 }, // Dresden
  "10115": { lat: 52.5323, lon: 13.3846 }, // Berlin
  "80331": { lat: 48.1372, lon: 11.5755 }, // Munchen
  // ... ~8,000 entries
};
```

### Updated Employee Type with Accuracy
```typescript
// src/types/employee.ts
export interface Employee {
  id: string;
  name: string;
  postcode: string;           // Required for local geocoding
  street?: string;            // Optional, for accurate mode
  city?: string;              // Auto-filled from postcode lookup
  team: string;
  department?: string;
  role?: string;
  assignedOffice?: string;
  coords?: { lat: number; lon: number };
  geocodeAccuracy: 'postcode-centroid' | 'address';
  geocodeStatus: 'pending' | 'success' | 'failed';
}
```

### Clear All Data Function
```typescript
// src/utils/clearAllData.ts
import { useEmployeeStore } from '../stores/employeeStore';
import { useOfficeStore } from '../stores/officeStore';

export function clearAllStoredData(): void {
  // Clear Zustand stores
  useEmployeeStore.getState().clearEmployees();
  useOfficeStore.getState().clearOffices();

  // Clear localStorage completely
  localStorage.clear();

  // Clear any sessionStorage (API key)
  sessionStorage.clear();
}
```

### Consent Modal Button Parity (GDPR Compliant)
```typescript
// Buttons must have equal visual prominence per GDPR/EAA 2025
const buttonStyle = {
  padding: '12px 24px',
  borderRadius: '6px',
  fontSize: '16px',
  fontWeight: 500,
  cursor: 'pointer',
  minWidth: '120px',
};

// Both buttons same style, different colors of equal prominence
<button style={{ ...buttonStyle, backgroundColor: '#f0f0f0', color: '#333' }}>
  Cancel
</button>
<button style={{ ...buttonStyle, backgroundColor: '#4a90d9', color: 'white' }}>
  Enable Geocoding
</button>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Environment variables for API keys | User-provided keys at runtime | GDPR/security best practice | Keys never in bundle |
| Full address geocoding by default | Postcode-only local geocoding | Privacy-first design | No data leakage |
| Unencrypted localStorage | AES-encrypted localStorage | GDPR data protection | Casual inspection prevented |
| No data limits | 1000 employees, 20 offices, 5MB files | Resource protection | Prevents browser DoS |

**Current (2025-2026):**
- GDPR enforcement intensified: equal button prominence required
- European Accessibility Act (June 2025): WCAG 2.2 for consent UIs
- Meta tag CSP widely supported; plugin approach available for complex cases
- Web Crypto API stable but async-only; crypto-js remains simpler for sync use cases

## Open Questions

1. **Postcode data source preference**
   - What we know: WZB plz_geocoord (Apache 2.0, ~8k entries) and zauberware (CC0, ~16k entries) both available
   - What's unclear: Whether more entries needed, zauberware includes more fields
   - Recommendation: Use WZB for simpler format; can upgrade to zauberware if city names needed

2. **CSP strictness in development**
   - What we know: Vite HMR requires 'unsafe-inline' for scripts
   - What's unclear: Whether to use different CSP in dev vs prod
   - Recommendation: Use meta tag with 'unsafe-inline' for dev simplicity; document that prod could be stricter

3. **Encryption key derivation**
   - What we know: Key in JS is not truly secret
   - What's unclear: Whether to use static key or derive from something
   - Recommendation: Use static versioned key; this is obfuscation not security

## Sources

### Primary (HIGH confidence)
- [WZB plz_geocoord GitHub](https://github.com/WZBSocialScienceCenter/plz_geocoord) - German postcode centroids, Apache 2.0
- [MDN AES-GCM](https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams) - Web Crypto API reference
- [Zustand Persist Docs](https://zustand.docs.pmnd.rs/integrations/persisting-store-data) - Custom storage integration

### Secondary (MEDIUM confidence)
- [Encrypted localStorage with Zustand](https://dev.to/cristhianleonli/encrypted-localstorage-with-zustand-4fdi) - crypto-js + Zustand pattern
- [vite-plugin-content-security-policy](https://github.com/Coreoz/vite-plugin-content-security-policy) - CSP Vite plugin
- [Cookie Banner Design 2026](https://secureprivacy.ai/blog/cookie-banner-design-2026) - GDPR UX requirements
- [Chris Veness AES-GCM Gist](https://gist.github.com/chrisveness/43bcda93af9f646d083fad678071b90a) - Web Crypto example

### Tertiary (LOW confidence)
- [OpenPLZ API](https://www.openplzapi.org/de/) - Alternative postcode source (API, not bulk download)
- [zauberware postal-codes](https://github.com/zauberware/postal-codes-json-xml-csv) - Alternative with more fields

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - crypto-js is well-established, Zustand pattern documented
- Architecture: HIGH - patterns from official docs and established tutorials
- Postcode data: HIGH - WZB dataset verified, Apache 2.0 licensed
- CSP configuration: MEDIUM - meta tag approach simple but may need adjustment
- GDPR UX: MEDIUM - based on 2025/2026 articles, regulations evolving

**Research date:** 2026-02-07
**Valid until:** 30 days (stable domain, slow-moving regulations)
